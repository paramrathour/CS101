\section{Advance Concepts}
\subsection{Dynamic Programming}
Dynamic Programming (DP) is an algorithmic technique for solving an optimization problem by breaking it down into simpler subproblems and utilizing the fact that the optimal solution to the overall problem depends upon the optimal solution to its subproblems.\\
\textbf{Dynamic Programming Methods}
\begin{itemize}
\item \textbf{Top-down with Memoization} - 
In this approach, we try to solve the bigger problem by recursively finding the solution to smaller sub-problems.
Whenever we solve a sub-problem, we cache its result so that we don’t end up solving it repeatedly if it’s called multiple times.
Instead, we can just return the saved result.
This technique of storing the results of already solved subproblems is called Memoization.
\item \textbf{Bottom-up with Tabulation} - 
Tabulation is the opposite of the top-down approach and avoids recursion.
In this approach, we solve the problem ``bottom-up'' (i.e. by solving all the related sub-problems first).
This is typically done by filling up an n-dimensional table.
Based on the results in the table, the solution to the top/original problem is then computed.
\end{itemize}
\begin{minipage}{0.5\textwidth}
Recursive Formula
\begin{minted}[frame=lines,linenos]{cpp}
int fibonacci(int n){
    if(n <= 1) {
        return n;
    }
    else {
        fibonacci(n-1)+fibonacci(n-2);
    }
}
\end{minted}
\end{minipage}
\begin{minipage}{0.5\textwidth}
Bottom-up with Tabulation
\begin{minted}[frame=lines,linenos]{cpp}
int fibonacci[n];
fibonacci[0] = 0;
fibonacci[1] = 1;
for (int i = 2; i < n; ++i)
{
    fibonacci[i] = fibonacci[i-1] + fibonacci[i-2];
}
cout<<fibonacci[n];
\end{minted}
\end{minipage}
\\[0.2em]
Solve questions \ref{itm:gp}, \ref{itm:dn}, \ref{itm:part} of practice problems \ref{pp4} and \ref{itm:cs}, \ref{itm:dw} of practice problems \ref{pp6} using dynamic programming
%\subsection*{Fun Video}
\subsection{Greedy Algorithms}
A greedy algorithm, as the name suggests, always makes the choice that seems to be the best at that moment. Means, it makes a locally-optimal choice in the hope that this choice will lead to a globally-optimal solution\\
In many problems, a greedy strategy does not usually produce an optimal solution, but nonetheless, a greedy heuristic may yield locally optimal solutions that approximate a globally optimal solution in a reasonable time.\\
\textbf{An Example}\\
Greedy algorithms to determine minimum number of coins to give while making change.
These are the steps a human would take to emulate a greedy algorithm to represent 36 cents using only 1, 5, 10, 20 coins.
\begin{figure}[H]
\centering
\includegraphics[width=0.35\linewidth]{Greedy Algorithm Demo.pdf}
\end{figure}
The coin of the highest value, less than the remaining change owed, is the local optimum\\
As a practice solve question \ref{itm:ef} of practice problems \ref{pp6} using greedy approach\\
\subsection*{References}
\href{https://youtu.be/aPQY__2H3tE}{5 Simple Steps for Solving Dynamic Programming Problems}\\
\href{https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews/m2G1pAq0OO0}{What is Dynamic Programming}\\
\href{https://projecteuler.net/problem=31}{Coin sums: Project Euler}

\href{https://en.wikipedia.org/wiki/Greedy_algorithm}{Greedy Algorithms: Wikipedia}